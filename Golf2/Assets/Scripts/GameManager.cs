using System.Collections;
using UnityEngine;

public class GameManager : MonoBehaviour
{
    public Transform[] playerPositions;
    public GameObject playerPrefab;
    public Transform playerParent;

    private CardManager cardManager;

    public int currentPlayerTurn;
    private int globalTurnCount = 0;
    private int playerCount;
    public GameObject camera;
    public GameObject deckAndDiscardPileParent;

    private float cameraRotateDuration = 0.75f;
    void Start()
    {
        playerCount = 4;
        cardManager = GameObject.FindGameObjectWithTag("CardManager").GetComponent<CardManager>();
        GeneratePlayers(playerCount);
        cardManager.DrawAndDiscardCard();
    }

    public void GeneratePlayers(int amount)
    {
        for (int i = 0; i < amount && i < 4; i++)
        {
            GameObject newPlayer = Instantiate(playerPrefab, playerPositions[i].position, playerPositions[i].rotation);
            newPlayer.name = $"Player{i+1}";
            newPlayer.transform.parent = playerParent;
        }
    }


    public void NextTurn()
    {
        currentPlayerTurn = (currentPlayerTurn + 1) % playerCount;
        if (currentPlayerTurn == 0) globalTurnCount++;
        if (!cardManager.deckCardDrawn)
        {
            cardManager.DrawAndDiscardCard();
        }
        cardManager.SetDeckDrawable(false);

        StartCoroutine(RotateOverTime(cameraRotateDuration));
    }


    // Generated by ChatGPT
    private IEnumerator RotateOverTime(float duration)
    {
        // The target rotation angle for the camera and the pile
        float targetRotation = camera.transform.rotation.eulerAngles.z + 90;

        // Start from the current rotation angles
        float startCameraRotation = camera.transform.rotation.eulerAngles.z;
        float startPileRotation = deckAndDiscardPileParent.transform.rotation.eulerAngles.z;

        // Time passed during the rotation
        float elapsedTime = 0f;

        // Gradually rotate until the target rotation is reached
        while (elapsedTime < duration)
        {
            float t = elapsedTime / duration; // Normalized time (0 to 1)

            // Interpolate the rotation between the start and target values
            camera.transform.rotation = Quaternion.Euler(0, 0, Mathf.Lerp(startCameraRotation, targetRotation, t));
            deckAndDiscardPileParent.transform.rotation = Quaternion.Euler(0, 0, Mathf.Lerp(startPileRotation, targetRotation, t));

            // Increase the elapsed time
            elapsedTime += Time.deltaTime;

            yield return null; // Wait for the next frame
        }

        // Ensure the final rotation is exactly the target rotation
        camera.transform.rotation = Quaternion.Euler(0, 0, targetRotation);
        deckAndDiscardPileParent.transform.rotation = Quaternion.Euler(0, 0, targetRotation);
    }
}