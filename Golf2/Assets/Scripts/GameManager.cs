using System.Collections;
using UnityEngine;
using TMPro;

public class GameManager : MonoBehaviour
{
    public Transform[] playerPositions;
    private PlayerManager[] playerManagers;
    public GameObject playerPrefab;
    public Transform playerParent;

    private CardManager cardManager;

    public int currentPlayerTurn;
    private int globalTurnCount;
    private int playerCount;
    public GameObject camera;
    public GameObject deckAndDiscardPileParent;
    public bool rotating = false;

    public GameObject endGameScreen;
    public TextMeshProUGUI scoreText;
    public bool gameOver = false;

    private float cameraRotateDuration = 0.75f;

    void Start()
    {
        playerCount = 4;
        cardManager = GameObject.FindGameObjectWithTag("CardManager").GetComponent<CardManager>();
        GeneratePlayers(playerCount);
        cardManager.DrawAndDiscardCard();
    }

    public void GeneratePlayers(int amount)
    {
        playerManagers = new PlayerManager[amount];
        for (int i = 0; i < amount && i < 4; i++)
        {
            GameObject newPlayer = Instantiate(playerPrefab, playerPositions[i].position, playerPositions[i].rotation);
            newPlayer.name = $"Player{i+1}";
            newPlayer.transform.parent = playerParent;
            playerManagers[i] = newPlayer.GetComponent<PlayerManager>();
        }
    }


    public void NextTurn()
    {
        if (currentPlayerTurn == playerCount - 1) globalTurnCount++;
        if (globalTurnCount == 6)
        {
            EndGame();
            return;
        }
        currentPlayerTurn += 1;
        currentPlayerTurn %= playerCount;
        playerManagers[currentPlayerTurn].EnlargeCards(true);

        if (!cardManager.deckCardDrawn && // Did not draw card
            !cardManager.discardSwitchedWithCardInHand) // Did not switch in-hand card with discarded card (They flipped a card without drawing)
        {
            cardManager.DrawAndDiscardCard();
        }

        cardManager.SetDeckDrawable(true);
        cardManager.discardSwitchedWithCardInHand = false;

        StartCoroutine(RotateOverTime(cameraRotateDuration));
    }


    // Generated by ChatGPT
    private IEnumerator RotateOverTime(float duration)
    {
        rotating = true;
        // The target rotation angle for the camera and the pile
        int targetRotation = (int)camera.transform.rotation.eulerAngles.z + 90;
        Debug.Log($"Rotating to {targetRotation} for player = {currentPlayerTurn} and global turn = {globalTurnCount}");

        // Start from the current rotation angles
        float startCameraRotation = camera.transform.rotation.eulerAngles.z;
        float startPileRotation = deckAndDiscardPileParent.transform.rotation.eulerAngles.z;

        // Time passed during the rotation
        float elapsedTime = 0f;

        // Gradually rotate until the target rotation is reached
        while (elapsedTime < duration)
        {
            float t = elapsedTime / duration; // Normalized time (0 to 1)

            // Interpolate the rotation between the start and target values
            camera.transform.rotation = Quaternion.Euler(0, 0, Mathf.Lerp(startCameraRotation, targetRotation, t));
            deckAndDiscardPileParent.transform.rotation = Quaternion.Euler(0, 0, Mathf.Lerp(startPileRotation, targetRotation, t));

            // Increase the elapsed time
            elapsedTime += Time.deltaTime;

            yield return null; // Wait for the next frame
        }

        // Ensure the final rotation is exactly the target rotation
        camera.transform.rotation = Quaternion.Euler(0, 0, targetRotation);
        deckAndDiscardPileParent.transform.rotation = Quaternion.Euler(0, 0, targetRotation);
        rotating = false;
    }

    private void EndGame()
    {
        gameOver = true;

        string scoreString = "";
        for (int i = 0; i < playerManagers.Length; i++)
        {
            string formattedPlayerScore = $"Player {i + 1} score: {playerManagers[i].CalculateScore()}";
            scoreString += $"{formattedPlayerScore}\n";
        }
        scoreText.text = scoreString;
        endGameScreen.SetActive(true);
        deckAndDiscardPileParent.SetActive(false);
    }
}